### 问题描述

> https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/

假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。

注意数组中可能存在重复的元素。

```
输入: [2,2,2,0,1]
输出: 0
```

### 思路

* 假设 `var arr = [a, b, c, d, e, f, g, h, i, j ,k]` 为初始数组，则必有 `k >= a`，当数组在元素 e 发生旋转，旋转为 `var reversedArr = [e, f, g, h, i, j ,k, a, b, c, d]` 则必有 `d <= e`

* 若数组 `arr[arr.length - 1] > arr[0]` 则数组未旋转过

* 若 `arr[arr.length - 1] < arr[0]` 则发生过旋转

* 对于旋转过的数组，利用二分法进行大小比较，设初始最小元素为 `arr[0]`，设数组中位数为 `arr[mid]`

* 若 `arr[0] > arr[mid]` 则说明 `mid` 位置的元素应该在 `arr[0]` 元素之前，那么在左半区继续查找，并同时设置 `min = arr[mid]`

* 若 `arr[0] === arr[mid]` 则说明 `mid` 位置元素和 `arr[0]` 相同，那么在哪边继续寻找为止

* 因为假设了 `min = nums[0]`，分析2种情况，有重复和无重复情况

  - 无重复数情况：最左边不可能为最小值，在二分查找的时候也不可能存在 `min = nums[mid]` 情况

  - 有重复数情况，若 `min = nums[0]` 就是我们要找的最小数，那么后面无论怎么寻找都找不到比 `min` 还小的数

  - 有重复数情况，若 `min = nums[0]` 在之后寻找中还有比 `min` 更小的数，那么 `left = left + 1` 将整体空间缩小的方式，不会将可能的最小值排除之外

### Key Points

* 既然存在相同元素，在判断的时候需要特别注意，min 和 mid 的大小情况

* mid 和 min 相等的情况是这个题目的关键

### 官方解答